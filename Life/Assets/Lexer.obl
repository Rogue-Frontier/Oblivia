{
    
    //@private
	TokenType:enum{
        backslash:"\\\\"
        eof:"eof"   str:"str"   name:"name"
        comma:  ","
        semicolon:  ";"
        colon:  ":"
		block_l:"{" block_r:"}" tuple_l:"(" tuple_r:")"
        array_l:"[" array_r:"]" angle_l:"<" angle_r:">"
		caret:  "^" period: "." bang:   "!" question:   "?"
		plus:   "+" minus:  "-" star:   "*" slash:  "/"
		equal:  "=" at:     "@" amp:    "&" pipe:   "|"

        coloneqq:   "≔"
        range:  "↕"

        count:  "⌗"
        yes:    "⟙",
        no:     "⟘"
        not:    "¬"

        quote:  "\'"
        cash:   "$" percent:"%" hash:   "#"
        repeat: "¨" 
		times:  "×" divide: "÷"
		iota:   "ɩ" 
		divides:"∣" 
        floor:  "⌊" ceil:   "⌈"
        brack_l:"⟨" brack_r:"⟩" double_brack_l: "⟪" double_brack_r: "⟫"
        shell_brack_l:  "⟬" shell_brack_r:  "⟭" flat_paren_l:   "⟮" flat_paren_r:   "⟯"
        index_ascend:   "⍋" index_descend:  "⍒"
        i_beam: "⌶"	
		kronecker_product:      "⊗"
        log:    "⍟" 
        or:"∨"  and:"∧" nor:"⍱" nand:"⍲"    xor:"⊻"
        sum:"∑" product:"∏" increment:"∆"
        geq:"≥" leq:"≤"
		arrow_w:"←" arrow_e:"→" arrow_s:"↓" arrow_n:"↑"
        measure:"measure"

        keyboard:"⌨"
        not_eq:"≠"
    }
    IToken:interface{
    
    }
    StrToken:class{
        impl(IToken)
        type -> obj:TokenType/eof
        text -> str:""
    }
    MeasureToken:class{
        impl(IToken)
        type:TokenType/measure
        val->i4:0   measure->str:""     text:get{cat[val measure]}
    }
    Tokenizer:class {
        src->str:""     index->i4:0
        new(src:str): Tokenizer {
            ^src := ^^src
            Console/WriteLine(^src/Length)
        }
        GetAllTokens (): {
            tokens: List.IToken/ctor(),

            Read:label,
            t:Next(),
            not(t/type/val = "eof") ?+ {
	            //Console/WriteLine(cat[t/type " " t/text])
                Console/WriteLine(index)
                Console/WriteLine(cat["TokenVal:" t/type/val])
                Console/WriteLine(cat["token/text:" t/text/val])
                tokens/Add(t)
                Console/WriteLine(cat["TokenCount: " tokens/Count])
                go(Read)
            }
            ^: tokens
        }
        Next():{
            str(c:Row.char): str/Join("" c)
            inc():{index:=(+:_ 1)}
            
            alphanumeric:sat(
                ?(c:char):(
                    (((c≥⌨"a") ∧ (c≤⌨"z")) ?+ { Console/WriteLine(cat["az: " c]), ^:yes } ?- no)∨
                    (((c≥⌨"A") ∧ (c≤⌨"Z")) ?+ { Console/WriteLine(cat["AZ: " c]), ^:yes } ?- no)∨
                    ((c = numeric) ?+ { Console/WriteLine(cat["09: " c]), ^:yes } ?- no) ∨
                    ((c=⌨"_") ?+ { Console/WriteLine(cat["_: " c]), ^:yes } ?- no) ?+ {
                        Console/WriteLine(cat["ALPHANUMERIC: " c])
                        ^:yes
                    } ?- no
                )
            )
            numeric:sat(?(n:char):
                ((n≥⌨"0") ∧ (n≤⌨"9")) ?+ {
                    Console/WriteLine(cat["NUMERIC: " c])
                    ^:yes
                }
            )
            Check:label
            //Console/WriteLine(cat["Check" src])
            ,(index≥(src/Length))?+{
                Console/WriteLine(cat["index: " index])
                Console/WriteLine(cat["src/Length: " src/Length])
                Console/WriteLine("EOF")
                ^^: StrToken {
                    type := TokenType/eof
                }
            } ?- {
                Console/WriteLine("not EOF")
            }
            Console/WriteLine("Read")
            c:src(index)
            Console/WriteLine(c)
            c?{
                ⌨"/":{
                    src((+:index 1))?{
                        ⌨"/":{
                            inc() inc(),
                            (<:index src/Length)∧(src.index/Get()≠⌨"\n")?++inc()
                            go.Check
                        }
                        ⌨"*":{
                            inc() inc(),
                            (<:index src/Length)∧(src.index/Get()≠⌨"\n")?++inc()
                            checkStop:no,
                            (<:index src/Length)?++{
                                (src.index=⌨"*")?+{
                                    inc()   checkStop:=yes
                                } ?- (src.index=⌨"/")∧checkStop?+{
                                    inc()   go.Check
                                } ?- {
                                    inc()   checkStop:=no
                                }
                            }
                            go.Check
                        }
                        _:{^^:fall}
                    }
                }
                ⌨"~":{
                    inc(),
                    (<:index src/Length)∧(src.index/Get()≠⌨"~")?+inc()
                    inc()   go.Check
                }
                ⌨"\"":{
                    dest:(+:index 1)    v:"",
                    //pr(src(dest)()),
                    (<:dest src/Length)?++{
                        src.dest()?{
                            ⌨"\\":{
                                dest:=(+:_ 1)
                                v:=cat[_ src(dest)?{
                                    ⌨"r": "\r"
                                    ⌨"n": "\n"
                                    ⌨"t": "\t"
                                    ⌨"\\": "\\"
                                    ⌨"\"": "\""
                                    ⌨"\'": "\'"
                                }]
                                dest:=(+:_ 1)
                            }
                            ⌨"\"":go.Stop
                            _:{
                                v:=(+:v src.dest/Get())
                                dest:=(+:_ 1)
                            }
                        }
                    }
                    Stop:label
                    //pr(cat["index " index])
                    dest:=(+:_ 1)
                    index:=dest
                    ^^:StrToken{
                        type:=TokenType/str
                        text:=^^v
                    }
                }
                any(⌨" " ⌨"\r" ⌨"\n" ⌨"\t"):{
                    inc()
                    go.Check
                }
                numeric:{
                    dest:index val:0
                    Read:label,
                    (<:dest src/Length)?+{
                        ch:src.dest
                        ch?{
                            numeric:{
                                val := (*:_ 10)+(-:ch ⌨"0")
                                dest := _+1
                                go.Read
                            }
                            ⌨"_":{
                                dest := _+1
                                go.Read
                            }
                            _:{}
                        }
                    }
                    s:src/Substring(index,(-:dest index))
                    index:=dest
                    ^^:MeasureToken{
                        val:=^^val 
                        measure:=""
                    }
                }
                sat(?(c:char) TokenType/_valToKey(c/ToString())/can_get):{
                    Console/WriteLine("TOKEN")
                    _t:TokenType/_valToKey(c/ToString())
                    index := _+1
                    ^^:StrToken{
                        type:=_t
                        text:=c/ToString()
                    }
                }


                alphanumeric:{
                    dest:index  escape:no   v:""

                    Read:label,
                    (<:dest src/Length)?+{
                        ch:src(dest)
                        Console/WriteLine(ch)
                        ch?{
                            alphanumeric:{
                                Console/WriteLine(cat["alphanumeric: " ch])
                                v:=(+:v ch)
                                dest := _+1
                                go.Read
                            }
                            ⌨"\\\\":{
                                dest := _+1
                                escape:=yes
                                go.Read
                            }
                            _:{
                                escape?+{
                                    v := v+ch
                                    escape:=false
                                    dest := _+1
                                    go.Read
                                } ?- go.Done
                            }
                        }
                    }
                    Done:label
                    index:=dest
                    ^^:StrToken{
                        type:=TokenType/name
                        text:=^^v
                    }
                }
            }
        }
	}
}
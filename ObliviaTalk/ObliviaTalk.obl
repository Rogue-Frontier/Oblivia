{
	dict:[
		"addi(<lhs> <rhs>)"							:	"<lhs> + <rhs>"
		"subi(<lhs> <rhs>)"							:	"<lhs> - <rhs>"
		"divi(<lhs> <rhs>)"							:	"<lhs> // <rhs>"
		"divf(<lhs> <rhs>)"							:	"<lhs> / <rhs>"
		"muli(<lhs> <rhs>)"							:	"<lhs> * <rhs>"
		"<name>: var"								:	"var <name>"
		"<name>: const(<val>)"						:	"def <name> = <val>"
		"<name>:[<items>]"							:	"var <name> = [<items>]"
		"<name>:Grid(<type> <width> <height>)"		:	"var <name>[<width> <height>] of <type>"
		"for(<name> <width> <height>) { <body> }"	:	"for <name>:Int32 = <start> to <end> do <body> end"
		"<name>: ?(<par>) <body>"					:   "function <name>(<arg>) do <body> end"
		"<cond> ?+ <yes> ?- <cond2> ?+ <yes> ?- <no>":	"if <cond> do <yes> else if <cond2> do <yes> else <no>"
		"<cond> ?+ <yes> ?- <no>"					:	"if <cond> do <yes> else do <no> end"
		"<cond> ?+ <yes>"							:	"if <cond> do <yes> end"
	]
	Matcher: class {
		parts: List.obj
		match: ?(src:str){
			ind: 0
			good:yes
			parts | ?(p){
				p = MatchStr:s ?+ {
					not(src/Substring(ind)/StartsWith(s/src)) ?+ {
						good := false	
					}
				} ?- p = MatchExp:e ?+ {
					
				}
			}
		}
	}
	MatchStr: class {
		src: str
	}
	MatchExp: class {
		all: bit
	}
	SrcStr: class {
		src: str
		end: Array(i4 1)
	}
	print:Console/WriteLine
	main:?(){
		print*Reader {
			src := "a:(int int) b:{1 2 3} c:\"aaaaaa\""
		}/read()
	}
	Reader: class {
		alpha:		any*ch_arr."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
		colon:		any*ch_arr.":"
		l_paren:	parse_char."("
		r_paren:	parse_char.")"
		l_square:	parse_char."["
		r_square:	parse_char."]"
		l_curly:	parse_char."{"
		r_curly:	parse_char."}"
		l_angle:	parse_char."<"
		r_angle:	parse_char.">"
		quote:		parse_char."\""
		src:str

		i:		0
		inc:	?(){i := addi(_ 1)}
		cur:	get*src.i()
		good:	get*lt(i src/Length)
		arr:	Array(i4 1)
		read_name: ?(){
			start:i inc(),
			(good ?+ (cur = alpha) ?- no) ?% inc()
			arr_set(arr, [:i4 start], i),
			print(cat["name " start " " i])
		}
		read_paren:?(){
			start:i inc(),
			(good ?+ not(cur = r_paren) ?- no) ?% step()
			inc()
			arr_set(arr, [:i4 start], i),
			print(cat["paren " start " " i])
		}
		read_square:?(){
			start:i inc(),
			(good ?+ not(cur = r_square) ?- no) ?% step()
			inc()
			arr_set(arr, [:i4 start], i),
			print(cat["square " start " " i])
		}
		read_curly:?(){
			start:i inc(),
			(good ?+ not(cur = r_curly) ?- no) ?% step()
			inc()
			arr_set(arr, [:i4 start], i),
			print(cat["curly " start " " i])
		}
		read_angle:?(){
			start:i inc(),
			(good ?+ not(cur = r_angle) ?- no) ?% step()
			inc()
			arr_set(arr, [:i4 start], i),
			print(cat["angle " start " " i])
		}
		read_quote:?(){
			start:i inc(),
			(good ?+ not(cur = quote) ?- no) ?% step()
			inc()
			arr_set(arr, [:i4 start], i),
			print(cat["quote " start " " i])
		}
		step:?()
			cur ?{
				alpha:		read_name()
				colon:		inc()
				l_paren:	read_paren()
				l_square:	read_square()
				l_curly:	read_curly()
				l_angle:	read_angle()
				quote:		read_quote()
				default:	inc()
			}
		read:?(){
			arr := arr_mk(i4 src/Length)
			good ?% step()
			print."DONE"
			^: SrcStr{ src := ^^^^src end := arr }
		}
	
	}
}
{
	dict:[
		"addi(<lhs> <rhs>)"								:	"<lhs> + <rhs>"
		"subi(<lhs> <rhs>)"								:	"<lhs> - <rhs>"
		"divi(<lhs> <rhs>)"								:	"<lhs> // <rhs>"
		"divf(<lhs> <rhs>)"								:	"<lhs> / <rhs>"
		"muli(<lhs> <rhs>)"								:	"<lhs> * <rhs>"
		"<name>: var"									:	"var <name>"
		"<name>: const(<val>)"							:	"def <name> = <val>"
		"<name>:[<items>]"								:	"var <name> = [<items>]"
		"<name>:Grid(<type> <width> <height>)"			:	"var <name>[<width> <height>] of <type>"
		"for(<name> <width> <height>) { <body> }"		:	"for <name>:Int32 = <start> to <end> do <body> end"
		"<name>: ?(<par>) <body>"						:   "function <name>(<arg>) do <body> end"
		"<cond> ?+ <yes> ?- <cond2> ?+ <yes> ?- <no>"	:	"if <cond> do <yes> else if <cond2> do <yes> else <no>"
		"<cond> ?+ <yes> ?- <no>"						:	"if <cond> do <yes> else do <no> end"
		"<cond> ?+ <yes>"								:	"if <cond> do <yes> end"
	]
	
	alpha:		any*ch_arr."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
	colon:		any*ch_arr.":"
	l_paren:	parse_char."("
	r_paren:	parse_char.")"
	l_square:	parse_char."["
	r_square:	parse_char."]"
	l_curly:	parse_char."{"
	r_curly:	parse_char."}"
	l_angle:	parse_char."<"
	r_angle:	parse_char.">"
	quote:		parse_char."\""
	space:		any*ch_arr." \t\r\n"
	Capture: class {
		items: List.obj/ctor()
		write(): {
			s:""
			items | ?(p){
				s := append(_ p/text)
			}
			^: s
		}
		fmt(s:""):{
			items | ?(p){
				p = CaptureStr:c ?+ {
					print(cat[c/name "=" c/text])
					s := s/Replace(c/name c/text)
				}
			}
			^: s
		}
	}
	CaptureStr: class {
		expr: no
		text: str
		name: str
	}
	Matcher: class {
		parts: List.obj/ctor()
		read(other:StrDex):{
			good:yes
			ind_l:0
			ind_r:0
			result: Capture{}
			matchAll: no
			matchNode: CaptureStr
			and[good lt(ind_l other/len)] ?% {
				(other/src.ind_l() = space) ?+ {
					print."SPACE"
					ind_l := other/getEnd.ind_l
				} ?- {
					p:parts.ind_r(),
					(p = MatchStr:s) ?+ {
						lhs:other/src/Substring(ind_l s/len)
						print(cat["LHS    " lhs "\nEXPECT " s/src])
						not(lhs/Equals(s/src)) ?+ {
							matchAll ?+ {
								term: other/getTerm.ind_l
								matchNode/{
									text := append(_ cat[" " term])
								}
								ind_l := addi(_ term/Length)
								print(cat["capture more " lhs])
							} ?- {
								ind_l := 0
								print."NO MATCH"
							}
						} ?- {
							print."MATCH"
							result/items/Add* CaptureStr {
								name := lhs
								text := lhs
							}
							ind_l := addi(_ s/len)
							ind_r := addi(_ 1)
						}
					} ?- (p = MatchExp:e) ?+ {
						lhs:other/getTerm(ind_l)
						print(cat["LHS    " lhs "\nEXPECT " e/name])
						print."MATCH"
						item:CaptureStr{
							expr := yes
							text := lhs
							name := e/name
							print(cat["capture " lhs])
						}
						result/items/Add*item
						e/{
							matchAll := all
							matchAll ?+ {
								print."capture more"
								matchNode := item
							}
						}
						ind_l := addi(_ lhs/Length)
						ind_r := addi(_ 1)
					}
				}
			}
			^:result
		}
		parse(s:str): Matcher/new(Lexer/new(s)/read())
		new(from:StrDex): Matcher {
			i:0
			inc: ?(){i := addi(_ 1)}
			lt(i from/src/Length) ?% {
				from/getChar.i ?{
					space: {
						i := from/getEnd.i
						print."space"
					}
					any(l_paren r_paren l_square r_square l_curly r_curly): {
						s_: from/src/Substring(i 1)
						parts/Add*MatchStr{ src := s_ }
						inc()
						print._
					}
					l_angle: {
						print."TERM"
						parts/Add* MatchExp { all := yes name:= from/getTerm.i }
						i := from/getEnd.i
						#print._
					}
					default: {
						term: from/getTerm.i
						parts/Add*MatchStr{ src := term }
						i := from/getEnd.i
						print.term
					}
				}
			}
		}
	}
	MatchStr: class {
		src: str
		len: 'src/Length
	}
	MatchExp: class {
		all: yes
		name:str
	}
	StrDex: class {
		src: str
		end: Array(i4 1)
		getEnd(i:i4): end.i()
		getChar(i:i4): src.i()
		getTerm(i:i4): src/Substring(i subi(getEnd.i i))
		len: 'src/Length
	}
	print:Console/WriteLine
	main:?(){
		m1: Lexer/lex("divi(1 2)")
		m2: Matcher/parse("divi(<lhs> <rhs>)")
		cap: m2/read.m1
		print*cap/fmt("<lhs> // <rhs>")
		
		/*
		m1: Lexer/lex("[1 2 3 4]")
		m2: Matcher/parse("[<items>]")
		cap: m2/read.m1
		print*cap/fmt("array(<items>)")

		m1: Lexer/lex("NEIGHBOR_Y: [subi(1) subi(1) subi(1) 0 0 1 1 1]")
		m2: Matcher/parse("<name>:[<items>]")
		cap: m2/read.m1
		print*cap/fmt("var <name> = [<items>]")
		*/
		
		
	}
	Lexer: class {
		src:str
		i:		0
		inc():	{i := addi(_ 1)}
		cur:	'src.i()
		good:	'lt(i src/Length)
		end:	Array(i4 1)
		read_name(): {
			start:i inc(),
			(good ?+ (cur=alpha) ?- no) ?% inc()
			arr_set(end, [:i4 start], i),
			print(cat["name " start " " i])
		}
		read_paren(): {
			start:i inc(),
			(good ?+ not(cur=r_paren) ?- no) ?% step()
			inc()
			arr_set(end, [:i4 start], i),
			print(cat["paren " start " " i])
		}
		read_square(): {
			start:i inc(),
			(good ?+ not(cur=r_square) ?- no) ?% step()
			inc()
			arr_set(end, [:i4 start], i),
			print(cat["square " start " " i])
		}
		read_curly(): {
			start:i inc(),
			(good ?+ not(cur=r_curly) ?- no) ?% step()
			inc()
			arr_set(end, [:i4 start], i),
			print(cat["curly " start " " i])
		}
		read_angle(): {
			start:i inc(),
			(good ?+ not(cur=r_angle) ?- no) ?% step()
			inc()
			arr_set(end, [:i4 start], i),
			print(cat["angle " start " " i])
		}
		read_quote(): {
			start:i inc(),
			(good ?+ not(cur=quote) ?- no) ?% step()
			inc()
			arr_set(end, [:i4 start], i),
			print(cat["quote " start " " i])
		}
		read_space(): {
			start:i inc(),
			(good ?+ (cur=space) ?- no) ?% step()
			arr_set(end, [:i4 start], i)
			print(cat["space " start " " i])
		}
		step():
			cur ?{
				alpha:		read_name()
				colon:		inc()
				l_paren:	read_paren()
				l_square:	read_square()
				l_curly:	read_curly()
				l_angle:	read_angle()
				quote:		read_quote()
				space:		read_space()
				default:	inc()
			}
		read():{
			end := arr_mk(i4 src/Length)
			good ?% step()
			print."DONE"
			^: StrDex{ (src end) := ^^^^/(src end) }
		}

		new(s:str): Lexer { src := s }

		lex(s:str): Lexer/new(s)/read()

	}
}
{
	
	~
	test(?): match {
		string{}: print * args
		2: print * args
		!: print * "test"
	}
	init: match {
	}
	func(a:int void)
	func(int void)
	~
	BufferedList: class {
		items: HashSet-object/new!
		toAdd: HashSet-object/new!
		toRemove: HashSet-object/new!

		new!: BufferedList{}
		Add(e:object): {
			items/Contains-e ?+
				print*"already added" ?-
				toAdd/Add-e
		}
		Remove(e:object): {
			items/Contains-e ?+
				toRemove/Add-e ?-
				print*"already removed"
		}
		Update!: {
			items/UnionWith-toAdd
			items/ExceptWith-toRemove

			toAdd/Clear!
			toRemove/Clear!
		}
	}
	XY: class {
		x: double/Parse-"0"
		y: double/Parse-"0"
		xi:	get* int_from-x
		yi:	get* int_from-y
		xf: get* x
		yf: get* y
		xyi:get* pairi(xi yi)

		left:	get* XY/i(subi(0 1) 0)
		right:	get* XY/i(addi(0 1) 0)
		up:		get* XY/i(0 subi(0 1))
		down:	get* XY/i(0 addi(0 1))

		~
		l: prop(
			get:null	
			set:_ null
		)
		left:	set* { x := _arg }

		d: var-double
		e: val-double
		~

		i(x:int y:int): XY {
			x := double_from-^^x
			y := double_from-^^y
		}
		f(x:double y:double): XY {
			x := ^^x
			y := ^^y
		}
		add(rhs: XY): XY {
			x := addf(^^^x rhs/x)
			y := addf(^^^y rhs/y)
		}
		sub(rhs: XY): XY {
			x := subf(^^^x rhs/x)
			y := subf(^^^y rhs/y)
		}
		div(scale:int): XY {
			x := divf(^^^x scale)
			y := divf(^^^y scale)
		}
	}
	Tile: class {
		glyph: "@"@0
		front: ABGR/Magenta
		back: ABGR/Black
		arr(str:string): str | ?(c:char) Tile { glyph := c front := ABGR/White back := ABGR/Black }
		print(sf:Sf pos:XY): {
			sf/PrintChar(pos/(xi yi)% ^^/(glyph front back)%)
		}
	}
	Entity: interface {
		active: bool
	}
	Floor: class {
		name: "Floor"
		pos:XY
		env: true
		active: true
		tile: Tile {
			glyph := char_from-254
			#front := ABGR/Gray
			by: byte_from
			front := ABGR/RGBA * (51 51 75 addi(204 rand_range(0 25))) | by
			back := ABGR/Transparent

			# tile = new Tile(ABGR.RGBA(25, 25, 36, (byte)(204 + (r.NextFloat() * 51))), ABGR.Black, (char)254);
		}
		update!: {
		}
		new(pos:XY): Floor {
			pos := ^^pos
		}
		#register(Entity)
	}

	Wall: class {
		name: "Wall"
		pos: XY
		env: true
		active: true
		tile: get* Tile {
			glyph := char_from-249
			front := ABGR/Gray
			back := ABGR/Transparent
		}
	}


	Msg: class {
		tiles: Row-Tile
		time: double/Parse-"0"
		tick: int/Parse-"0"
		new(tiles:Row-Tile time:double tick:int): Msg {
			tiles := _0
			time := _1
			tick := _2
		}
		repeats: 1
		fadeTime: double/Parse-"0"
		once: get* repeats =+ 1
		text: get* tiles | ?(t:Tile) t/glyph
	}
	Enemy: class {
		hp: 100
		active: b1
		name: "Enemy"
		pos: XY
		world: World
		this: get* ^$
		tile: Tile {
			glyph := "E"[0]
			front := ABGR/Red
		}
		new(pos:XY world:World): Enemy {
			pos := _0
			world := _1
		}
		update!: {
			not-active ?+
				world/removeEntity*this	
		}
		damage(hp: int): {
			^^^hp := subi(_ hp)
			active := gt(^^^hp 0)
			#print * ^^^hp
		}
	}
	Player: class {
		~
		^(a:int): {
		}
		^[a:int]: {
		
		}
		data[a:int]: {
		
		}
		~
		name: "Player"
		pos: XY
		tile: Tile {
			glyph := "@"[0]
			front := ABGR/Magenta
		}
		active: b1
		busy: b0
		world: World
		log: List-Msg/new!
		cargo: List-Item/new!
		new(pos:XY world:World): Player {
			pos := _0
			world := _1
		}
		update!: {
			busy := b0
		}
		move(disp:XY): {
			dest: pos/add*disp
			grid: world/getGrid
			others: grid[dest/xyi]
			attack: b0
			others =- null ?+ {
				others |<not*attack> ?(e) {
					e/class =+ Enemy ?+ {
						ta: Tile/arr(cat["Attack " e/name])
						msg: Msg/new(ta time world/tick)
						log/Add*msg
						e/damage*10
						attack := b1
					}
				}
			}
			not-attack ?+ {
				world/hasFloor-dest ?+ {
					pos := dest
				}
			}
			busy := b1
		}
	}
	Item: class {
		type: ItemType
		pos: XY
		active: b1
		tile: Tile { glyph := "r"@0  front := ABGR/White }
		new(type:ItemType pos:XY): Item {
			type := _0
			pos := _1
			print * pos/x
		}
		update!: {
			
		}
		name: get* type/name
	}
	ItemType: class {
		name: string
	}
	World: class {
		tick: 0
		entities: BufferedList/new!
		updateGrid: b1
		grid: ConcurrentDictionary(Pt HashSet-object)/new!
		new!: World{}
		addEntity: entities/Add
		removeEntity: entities/Remove
		menu: object
		update!: {
			entities / {

				items | ?(e)
					not(e/active) ?+ Remove-e ?- e/update!
			}
			entities/Update!
			updateGrid := b1
			tick := addi(_ 1)
		}
		forceUpdate!: {
			entities/Update!
			updateGrid := b1
		}
		getGrid: get* {
			not-updateGrid ?+ { ^^ := grid }
			grid/Clear!
			#print* grid/Count
			entities/items | ?(e) grid/GetOrAdd(e/pos/xyi HashSet-object/new!)/Add-e
			updateGrid := b0
			^: grid
		}
		hasFloor(p:XY): {
			loc: getGrid[p/xyi]
			loc =- null ?+ 
				loc | ?(e)
					e/class =+ Floor ?+ {
						^^ := true
					}
			^: false
		}
		hasWall(p:XY): {
			loc: getGrid[p/xyi]
			loc =- null ?+ 
				loc | ?(e)
					e/class =+ Wall ?+ {
						^^ := true
					}
			^: false
		}
	}
	time: double/Parse-"0"
	move: b0
	player: Player
	world: World
	sf: Sf
	sf_ui: Sf
	menu: object * null
	init!: {
		print * [1 2 3] // _item =+ 1 ?+ _item

		world := World/new!
		add: world/addEntity
		range(0 30) | ?(y:int)
			range(0 30) | ?(x:int)
				add* Floor/new* XY/i(x y)
		player := Player/new(XY/i(0 0) world)
		
		,[
			player
			Enemy/new(XY/i(10 10) world)
			Item/new(ItemType { name := "gun" } XY/i(5 5))
		] | add
		world/update!
		sf := Sf/new(Runner/WIDTH Runner/HEIGHT scene/FONT_8x8)
		sf_ui := Sf/new(divi(muli(4 Runner/WIDTH) 3) Runner/HEIGHT scene/FONT_6x8)
	}
	update(delta:TimeSpan): {
		time := addf(_ delta/TotalSeconds)
		player/busy ?+
			world/update!
		menu =- null ?+
			menu/update*delta
	}
	render(delta:TimeSpan): {
		
		[sf sf_ui] // _item/Clear!
		grid: world/getGrid
		center: XY/i(sf/GridWidth sf/GridHeight)/div*2
		grid/Keys | ?(p:Pt)
			grid@p | ?(e) {
				e/tile/print(sf center/add*e/pos/sub*player/pos)
			}
		sf_ui/PrintStr(1 1 cat["tick: " world/tick] ABGR/White ABGR/Black)
		invMenu: {
			y: subi(sf/GridHeight 64)
			Sf/DrawRect(sf_ui 0 y 32 32 border)
			y := addi(_ 1)
			sf_ui/Print(2 y "Inventory" ABGR/White ABGR/Black)
			y := addi(_ 1)
			Sf/DrawRect(sf_ui 0 y 32 1 border)
			player/cargo | ?(it:Item) {
				y := addi(_ 1)
				it/tile/print(sf_ui XY/i(2 y))
				sf_ui/Print(4 y it/name ABGR/White ABGR/Black)
			}
		}
		log: {
			y: subi(sf/GridHeight 32)
			Sf/DrawRect(sf_ui 0 y 64 32 border)
			y := addi(_ 1)
			sf_ui/Print(2 y "Log" ABGR/White ABGR/Black)
			y := addi(_ 1)
			Sf/DrawRect(sf_ui 0 y 64 1 border)
			y := addi(_ 1)
			player/log | ?(msg:Msg) {
				x:2
				msg/tiles | ?(t:Tile) {
					t/print(sf_ui XY/i(x y))
					x := addi(_ 1)
				}
				y := mini(addi(_ 1) subi(sf_ui/GridHeight 1))
			}
		}
		menu =- null ?+ menu/render!
		,[sf sf_ui] | scene/Draw/Invoke
	}
	handle_key(kb:KB): {
		player/busy ?+ { ^^ := empty }
		menu =- null ?+ {
			menu/handle_key-kb
			^^ := empty
		}
		kb/IsPress ?[
			KC/Left:	XY/left
			KC/Right:	XY/right
			KC/Up:		XY/up
			KC/Down:	XY/down
		] | player/move
		kb/IsPress ?[
			KC/G: {
				getItems: get* world/getGrid[player/pos/xyi] | ?(it)
					it/class =+ Item ?+ 
						it ?-
						empty
				menu := SelectMenu/new(
					title: "Get Items"
					items: getItems
					invoke: ?(ind) {
						it: menu/items@ind
						world/removeEntity*it
						player/cargo/Add*it
						world/forceUpdate!
						menu/setItems*getItems
					}
				)
			}
			KC/S: {
				menu := SelectMenu/new(
					title: "Shoot Item"
					items: player/cargo/ToArray!
					invoke: ?(ind) {
						it: menu/items@ind
						menu := LookMenu {}
						# menu/setItems* player/cargo/ToArray!
					}
					pos: XY/i(0 26)
				)
			}
			KC/N: empty
		]
	}
	handle_mouse(state:HandState): {
		menu =- null ?+
			menu/handle_mouse*state
	}
	RO: RectOptions/new
	border: RO(ABGR/DeepPink ABGR/Black)
	borderMenu: RO(ABGR/DeepPink ABGR/Black b1 b0)
	SelectMenu: class {
		title:string
		items: Row-Item
		setItems(items:Row-Item): {
			^^^items := items
		}
		invoke: ValFunc * null
		escape: ValFunc * null

		time: double/Parse-"0"
		pos: XY/i(32 26)
		new(title:string items:Row-Item invoke:ValFunc * null escape:ValFunc*null pos:null): SelectMenu {
			title := _0
			items := _1
			invoke := _2
			escape := _3
			pos := _4 =- null ?+ _4 ?- _
		}
		update(delta:TimeSpan): {
			time := addf(_ delta/TotalSeconds)
		}
		handle_key(kb:KB): {
			kb/IsPress ?[
				KC/Escape: {
					escape =+ null ?+ {
						menu := null
					}
				}
			]
			kb/Press | ?(k) beq(k 65 90) ?+ {
				ind: subi(k 65)
				lt(ind items/Length) ?+
					invoke*ind
			}
		}
		handle_mouse(state:HandState): {
			
		}
		render!: {
			x:pos/xi
			y:pos/yi
			w:32
			Sf/DrawRect(sf_ui x y int_from*Common/Lerp(time 0 divf(1 10) 1 w 1) 32 border)
			y := addi(_ 1)
			sf_ui/PrintStr(addi(x 2) y title ABGR/White ABGR/Black)
			y := addi(_ 1)
			Sf/DrawRect(sf_ui x y w 1 borderMenu)
			ind: 0
			items | ?(it) {
				y := addi(_ 1),
				[
					(addi(x 2) y it/tile/(glyph front back)%),
					(addi(x 4) y it/name ABGR/White ABGR/Black),
					(subi(addi(x w) 3) y ABC@ind ABGR/White ABGR/Black),
				] | sf_ui/Print
				ind := addi(_ 1)
			}
		}
	}
	LookMenu: class {
		allowSpace: false

		title:string
		invoke: ValFunc * null
		escape: ValFunc * null
		
		update(delta:TimeSpan): {
		
		}
		handle_key(kb:KB): {
			kb/IsPress ?[
				KC/Escape: {
					escape =+ null ?+ {
						menu := null
					}
				}
			]
			kb/Press | ?(k) beq(k 65 90) ?+ {
				ind: subi(k 65)
				lt(ind items/Length) ?+ 
					invoke =- null ?+ 
						invoke*ind
			}
		}
		handle_mouse(state:HandState): {
			
		}
		render!: {
			
		}
	}
	ABC: "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}
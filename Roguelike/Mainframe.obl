{

	~
	test(?): match {
		string{}: print * args
		2: print * args
		!: print * "test"
	}
	init: match {
	}


	func(a:int void)
	func(int void)
	~
	BufferedList: class {
		items: HashSet-object/new!
		toAdd: HashSet-object/new!
		toRemove: HashSet-object/new!

		new!: BufferedList{}
		Add(e:object): {
			items/Contains-e ?+
				print*"already added" ?-
				toAdd/Add-e
		}
		Remove(e:object): {
			items/Contains-e ?+
				toRemove/Add-e ?-
				print*"already removed"
		}
		Update!: {
			items/UnionWith-toAdd
			items/ExceptWith-toRemove

			~
				pr: ?(e:object) print* e/name
				(items | pr)
				(toRemove | pr)
			~
			
			toAdd/Clear!
			toRemove/Clear!
		}
	}
	XY: class {
		x: double_from-0
		y: double_from-0
		xi:	get* int_from-x
		yi:	get* int_from-y
		xf: get* x
		yf: get* y
		xyi:get* pairi(xi yi)

		left:	get* XY/i(subi(0 1) 0)
		right:	get* XY/i(addi(0 1) 0)
		up:		get* XY/i(0 subi(0 1))
		down:	get* XY/i(0 addi(0 1))

		~
		l: prop(
			get:null	
			set:_ null
		)
		left:	set* { x := _arg }

		d: var-double
		e: val-double
		~

		i(x:int y:int): XY {
			x := double_from-^^x
			y := double_from-^^y
		}
		f(x:double y:double): XY {
			x := ^^x
			y := ^^y
		}
		add(rhs: XY): XY {
			x := addf(^^^x rhs/x)
			y := addf(^^^y rhs/y)
		}
		sub(rhs: XY): XY {
			x := subf(^^^x rhs/x)
			y := subf(^^^y rhs/y)
		}
		div(scale:int): XY {
			x := divf(^^^x scale)
			y := divf(^^^y scale)
		}
	}
	Tile: class {
		glyph: "@"@0
		front: ABGR/Magenta
		back: ABGR/Black
		print(sf:Sf pos:XY): {
			pos % { sf/PrintChar(xi yi ^^^^glyph ^^^^front ^^^^back) }
		}
	}
	Entity: interface {
		active: bool
	}
	Floor: class {
		name: "Floor"
		pos:XY
		env: true
		active:true
		tile: Tile {
			glyph := char_from-249
			front := ABGR/Gray
			back := ABGR/Transparent
		}
		update!: {
			
		}
		new(pos:XY): Floor {
			pos := ^^pos
		}
		#register(Entity)
	}
	Enemy: class {
		hp: 100
		active: true
		name: "Enemy"
		pos: XY

		world: World

		this: get* ^$
		tile: Tile {
			glyph := "E"[0]
			front := ABGR/Red
		}
		
		new(pos:XY world:World): Enemy {
			pos := ^^pos
			world := ^^world
		}
		update!: {
			not-active ?+
				world/removeEntity*this	
		}
		damage(hp: int): {
			^^^hp := subi(_ hp)
			active := gt(^^^hp 0)
			#print * ^^^hp
		}
	}
	Player: class {
		~
		^(a:int): {
		}
		^[a:int]: {
		
		}
		data[a:int]: {
		
		}
		~
		name: "Player"
		pos: XY
		tile: Tile {
			glyph := "@"[0]
			front := ABGR/Magenta
		}
		active: true
		busy: false
		world: World
		log: List-string/new!
		new(pos:XY world:World): Player {
			pos := ^^pos
			world := ^^world
		}
		update!: {
			busy := false
		}
		move(disp:XY): {
			dest: pos/add*disp
			grid: world/getGrid
			others: grid[dest/xyi]
			attack: false
			others =- null ?+ {
				others |<not*attack> ?(e) {
					e/class =+ Enemy ?+ {
						log/Add*cat*["Attack " e/name]
						e/damage*20
						attack := true
					}
				}
			}


			not-attack ?+ {
				world/hasFloor-dest ?+ {
					pos := dest
				}
			}
			busy := true
		}
	}
	Item: class {
		type: ItemType
		pos: XY
		active: true
		tile: Tile { glyph := "r"@0  front := ABGR/White }
		new(type:ItemType pos:XY): Item {
			type := ^^type
			pos := ^^pos
			print * pos/x
		}
		update!: {
			
		}
		name: get* type/name
	}
	ItemType: class {
		name: string
	}
	World: class {
		tick: 0
		entities: BufferedList/new!
		updateGrid: true
		grid: ConcurrentDictionary(Pt HashSet-object)/new!
		new!: World{}
		addEntity: entities/Add
		removeEntity: entities/Remove
		menu: object
		update!: {
			entities % {
				items | ?(e)
					not(e/active) ?+ {
						Remove-e
					} ?- {
						e/update!
						#print* e/name
					}
			}
			entities/Update!
			updateGrid := true
			tick := addi(_ 1)
		}
		getGrid: get* {
			not-updateGrid ?+ {
				^^ := grid
			}
			grid/Clear!
			#print* grid/Count
			entities/items | ?(e)
				grid/GetOrAdd(e/pos/xyi HashSet-object/new!)/Add-e
			updateGrid := false
			^: grid
		}
		hasFloor(p:XY): {
			loc: getGrid[p/xyi]
			b:false
			loc =- null ?+ 
				loc | ?(e)
					e/class =+ Floor ?+ {
						b := true
					}
			^: b
		}
	}
	time: addf(0 0)
	move: false
	player: Player
	world: World
	sf: Sf
	sf_ui: Sf
	menu: object * null

	init!: {
		world := World/new!
		add: world/addEntity
		range(0 30) | ?(y:int)
			range(0 30) | ?(x:int)
				add* Floor/new* XY/i(x y)
		player := Player/new(XY/i(0 0) world)
		,[
			player
			Enemy/new(XY/i(10 10) world)
			Item/new(ItemType { name := "gun" } XY/i(5 5))
		] | add
		world/update!
		sf := Sf/new(Runner/WIDTH Runner/HEIGHT scene/FONT_8x8)
		sf_ui := Sf/new(divi(muli(4 Runner/WIDTH) 3) Runner/HEIGHT scene/FONT_6x8)
	}
	update(delta:TimeSpan): {
		time := addf(_ delta/TotalSeconds)
		player/busy ?+
			world/update!
	}
	render(delta:TimeSpan): {
		sf/Clear!
		sf_ui/Clear!
		grid: world/getGrid
		center: XY/i(sf/GridWidth sf/GridHeight)/div*2
		grid/Keys | ?(p:Pt)
			grid@p | ?(e) {
				e/tile/print(sf center/add * e/pos/sub* player/pos)
			}
		sf_ui/PrintStr(1 1 cat*["tick: " world/tick] ABGR/White ABGR/Black)
		
		y: subi(sf/GridHeight 32)
		Sf/DrawRect(sf_ui 0 y 64 32 border)
		y := addi(_ 1)
		player/log | ?(str:string) {
			sf_ui/PrintStr(1 y str ABGR/White ABGR/Black)
			y := mini(addi(_ 1) subi(sf_ui/GridHeight 1))
		}
		menu =- null ?+ menu/render!
		,[:Sf sf sf_ui] | scene/Draw/Invoke
	}
	handle_key(kb:KB): {
		player/busy ?+ { ^^ := null }
		menu =- null ?+ {
			menu/handle_key-kb
			^^ := null
		}
		kb/IsPress ?[
			KC/Left:	XY/left
			KC/Right:	XY/right
			KC/Up:		XY/up
			KC/Down:	XY/down
		] | player/move
		kb/IsPress ?[
			KC/G: {
				menu := GetMenu/new!
			}
			KC/N: null
		]
	}
	handle_mouse(state:HandState): {
	}
	border: RectOptions/new(ABGR/White ABGR/Black)
	GetMenu: class {
		items: List-object
		new(items:List-object): GetMenu {
			items := ^^items
		}
		handle_key(kb:KB): {
			kb/IsPress ?[
				KC/Escape: {
					menu := null
				}
			]
			kb/Press | ?(k) beq(k 65 90) ?+ {
				ind: subi(k 65)
				print * cat * ["get " ind]
			}
		}
		render!: {
			y:16
			Sf/DrawRect(sf_ui 0 y 32 32 border)
			y := addi(y 1)
			sf_ui/PrintStr(2 y "Get" ABGR/White ABGR/Black)
			y := addi(y 1)
			Sf/DrawRect(sf_ui 0 y 32 32 border)

			others: world/getGrid[player/pos/xyi]
			others =- null ?+ {
				ind: 0
				others | ?(it) {
					it/class =+ Item ?+ {
						y := addi(y 1)
						sf_ui/Print(2 y it/tile/glyph it/tile/front it/tile/back)
						sf_ui/Print(4 y it/name ABGR/White ABGR/Black)
						sf_ui/Print(subi(32 3) y ABC@ind ABGR/White ABGR/Black)
						ind := addi(ind 1)
					}
				}
			}
		}
	}
	ABC: "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}
{
 
 ~
 test(?): match {
  string{}: print * args
  2: print * args
  !: print * "test"
 }
 init: match {
 }
 func(a:int void)
 func(int void)
 ~


 test: multifunc {
  2: print * "two"
  (x:int): print * x
 }


 BufferedList(T): class {
  makeSet: HashSet-T/ctor
  items: makeSet!
  toAdd: makeSet!
  toRemove: makeSet!

  new!: BufferedList(T) {}
  Add(e:T): {
   items/Contains-e ?+
    print*"already added" ?-
    toAdd/Add-e
  }
  Remove(e:T): {
   items/Contains-e ?+
    toRemove/Add-e ?-
    print*"already removed"
  }
  Update!: {
   items/UnionWith-toAdd
   items/ExceptWith-toRemove
   ,
   [toAdd toRemove]//Clear!
  }
 }
 XY: class {
  (x y): (0 0) | double_from

  xi: get* int_from-x
  yi: get* int_from-y
  xf: get* x
  yf: get* y
  xyi:get* pairi(xi yi)
  left: get* XY/i(subi(0 1) 0)
  right: get* XY/i(addi(0 1) 0)
  up:  get* XY/i(0 subi(0 1))
  down: get* XY/i(0 addi(0 1))
  ~
  l: prop(
   get:null 
   set:_ null
  )
  left: set* { x := _arg }

  d: var-double
  e: val-double
  ~
  i(x:int y:int): XY {
   (x y) := (_0 _1) | double_from
  }
  f(^x ^y): XY {
   (x y) := (_0 _1)
  }
  add(rhs: XY): XY {
   x := addf(^^^x _0/x)
   y := addf(^^^y _0/y)
  }
  sub(rhs: XY): XY {
   x := subf(^^^x _0/x)
   y := subf(^^^y _0/y)
  }
  div(scale:int): XY {
   x := divf(^^^x _0)
   y := divf(^^^y _0)
  }
 }
 Tile: class {
  glyph: "@"@0,
  (front back): ABGR/(Magenta Black),

  arr(str:string): str | ?(c:char) Tile { glyph := c front := ABGR/White back := ABGR/Black }
  print(sf:Sf pos:XY): {
   sf/PrintChar(pos/(xi yi)% ^^^(glyph front back)%)
  }
 }
 Entity: interface {
  active: bool
 }
 Actor: interface {
  update!: {}
 }
 Floor: class {
  name: "Floor"
  pos:XY
  env: true
  active: true

  tile: Tile {
   glyph := char_from-254
   front := ABGR/RGBA * (51 51 75 addi(204 rand_range(0 25))) | byte_from
   back := ABGR/Transparent

   # tile = new Tile(ABGR.RGBA(25, 25, 36, (byte)(204 + (r.NextFloat() * 51))), ABGR.Black, (char)254);
  }
  update!: {
  }
  new(^pos): Floor {
   pos := _0
  }
  implement(Entity)
 }

 Wall: class {
  name: "Wall"
  pos: XY
  env: true
  active: true
  

  tile: get* Tile {
   glyph := char_from-249
   front := ABGR/Gray
   back := ABGR/Transparent
  }
  implement(Entity)
 }
 Msg: class {
  tiles: Row-Tile
  time: double/Parse-"0"
  tick: int/Parse-"0"
  new(^tiles ^time ^tick): Msg {
   (tiles time tick) := (_0 _1 _2)
  }
  repeats: 1
  fadeTime: double/Parse-"0"
  once: get* repeats =+ 1
  text: get* tiles | ?(t:Tile) t/glyph
 }
 Enemy: class {
  hp: 100
  active: b1
  name: "Enemy"
  pos: XY
  world: World
  this: get* ^$
  tile: Tile {
   glyph := "E"[0]
   front := ABGR/Red
  }
  new(^pos ^world): Enemy {
   pos := _0
   world := _1
  }
  update!: {
   not-active ?+
    world/removeEntity*this 
  }
  damage(^hp): {
   ^^^hp := subi(_ hp)
   active := gt(^^^hp 0)
  }
  implement(Entity Actor)
 }
 Player: class {
  ~
  ^(a:int): {
  }
  ^[a:int]: {
  
  }
  data[a:int]: {
  
  }
  ~
  name: "Player"
  pos: XY
  tile: Tile {
   glyph := "@"[0]
   front := ABGR/Magenta
  }
  active: true
  busy: false
  world: World
  log: List-Msg/ctor!
  cargo: List-Item/ctor!
  new(^pos ^world): Player {
   pos := _0
   world := _1
  }
  update!: {
   busy := false
  }
  move(disp:XY): {
   dest: pos/add*disp
   grid: world/getGrid
   others: grid[dest/xyi]
   attack: b0
   others =- null ?+ {
    others |<not*attack> ?(e) {
     e/_classSet/Contains-Enemy ?+ {
      log/Add*Msg/new(Tile/arr(cat["Attack " e/name]) time world/tick)
      e/damage*10
      attack := b1
     }
    }
   }
   not-attack ?+ {
    world/hasFloor-dest ?+ {
     pos := dest
    }
   }
   busy := true
  }
  
  implement(Entity Actor)
 }
 Item: class {
  type: ItemType
  pos: XY
  active: true
  tile: Tile { glyph := "r"@0  front := ABGR/White }
  new(^type ^pos): Item {
   type := _0
   pos := _1
  }
  update!: {
   
  }
  name: get* type/name

  implement(Entity)
 }
 ItemType: class {
  name: string
 }
 World: class {
  tick: 0
  entities: BufferedList-Entity/new!
  updateGrid: b1
  grid: ConcurrentDictionary(Pt HashSet-object)/ctor!
  new!: World{}
  addEntity: entities/Add
  removeEntity: entities/Remove
  update!: {
   entities / {
    items | ?(e)
     not(e/active) ?+ Remove-e ?- e/update!
   }
   entities/Update!
   updateGrid := b1
   tick := addi(_ 1)
  }
  forceUpdate!: {
   entities/Update!
   updateGrid := true
  }
  getGrid: get* {
   not-updateGrid ?+ { ^^ := grid }
   grid/Clear!
   #print* grid/Count
   entities/items | ?(e) grid/GetOrAdd(e/pos/xyi HashSet-Entity/ctor!)/Add*e
   updateGrid := false
   ^: grid
  }
  hasFloor(p:XY): {
   loc: getGrid[p/xyi]
   loc =- null ?+ 
    loc | ?(e)
     e/_classSet/Contains-Floor ?+ {
      ^^ := true
     }
   ^: false
  }
  hasWall(p:XY): {
   loc: getGrid[p/xyi]
   loc =- null ?+ 
    loc | ?(e)
     e/_classSet/Contains-Wall ?+ {
      ^^ := true
     }
   ^: false
  }
 }
 time: double/Parse-"0"
 move: b0
 camera: XY
 player: Player
 world: World
 sf: Sf
 sf_ui: Sf
 menu: Menu * null
 init!: {
  print * cat*[1 2, [:int 3 4]%]
  print * [1 2 3] // _item =+ 1 ?+ _item
  world := World/new!
  add: world/addEntity
  range(0 30) | ?(y:int)
   range(0 30) | ?(x:int)
    add* Floor/new* XY/i(x y)
  player := Player/new(XY/i(0 0) world)
  camera := player/pos
  ,[
   player
   Enemy/new(XY/i(10 10) world)
   Item/new(ItemType { name := "gun" } XY/i(5 5))
  ] | add
  world/update!
  sf := Sf/ctor(Runner/(WIDTH HEIGHT)% scene/FONT_8x8)
  sf_ui := Sf/ctor(divi(muli(4 Runner/WIDTH) 3) Runner/HEIGHT scene/FONT_6x8)
 }
 update(delta:TimeSpan): {
  time := addf(_ delta/TotalSeconds)
  player/busy ?+
   world/update!
  menu =- null ?+
   menu/update*delta
 }
 resetCamera!: {
  camera := player/pos
 }
 render(delta:TimeSpan): {
  [sf sf_ui] // Clear!
  grid: world/getGrid
  center: XY/i(sf/(GridWidth GridHeight)%)/div*2
  grid/Keys | ?(p:Pt)
   grid@p | ?(e) {
    e/tile/print(sf center/add*e/pos/sub*camera)
   }
  sf_ui/Print(1 1 cat["tick: " world/tick] ABGR/(White Black)%)
  invMenu: {
   y: subi(sf/GridHeight 64)
   Sf/DrawRect(sf_ui 0 y 32 32 border)
   y := addi(_ 1)
   sf_ui/Print(2 y "Inventory" ABGR/(White Black)%)
   y := addi(_ 1)
   Sf/DrawRect(sf_ui 0 y 32 1 border)
   player/cargo | ?(it:Item) {
    y := addi(_ 1)
    it/tile/print(sf_ui XY/i(2 y))
    sf_ui/Print(4 y it/name ABGR/(White Black)%)
   }
  }
  log: {
   y: subi(sf/GridHeight 32)
   Sf/DrawRect(sf_ui 0 y 64 32 border)
   y := addi(_ 1)
   sf_ui/Print(2 y "Log" ABGR/(White Black)%)
   y := addi(_ 1)
   Sf/DrawRect(sf_ui 0 y 64 1 border)
   y := addi(_ 1)
   player/log | ?(msg:Msg) {
    x:2
    msg/tiles | ?(t:Tile) {
     t/print(sf_ui XY/i(x y))
     x := addi(_ 1)
    }
    y := mini(addi(_ 1) subi(sf_ui/GridHeight 1))
   }
  }
  menu =- null ?+ menu/render!
  ,[sf sf_ui] | scene/Draw/Invoke
 }
 handle_key(kb:KB): {
  player/busy ?+ { ^^ := empty }
  menu =- null ?+ {
   menu/handle_key-kb
   ^^ := empty
  }
  kb/IsPress ?[
   KC/Left: XY/left
   KC/Right: XY/right
   KC/Up:  XY/up
   KC/Down: XY/down
  ] | ?(dir) {
   player/move*dir
   resetCamera!
  }
  kb/IsPress ?[
   KC/G: {
    getItems: get* world/getGrid[player/pos/xyi] | ?(it)
     it/_classSet/Contains-Item ?+ 
      it ?-
      empty
    menu := SelectMenu/new(
     title: "Get Items"
     items: getItems
     invoke: ?(ind) {
      it: menu/items@ind
      world/removeEntity*it
      player/cargo/Add*it
      world/forceUpdate!
      menu/setItems*getItems
     }
    )
   }
   KC/S: {
    menu := SelectMenu/new(
     title: "Shoot Item"
     items: player/cargo/ToArray!
     invoke: ?(ind) {
      it: menu/items@ind
      menu := LookMenu {}
      # menu/setItems* player/cargo/ToArray!
     }
     pos: XY/i(32 26)
    )
   }
   KC/N: empty
  ]
 }
 handle_mouse(state:HandState): {
  menu =- null ?+
   menu/handle_mouse*state
 }
 RO: RectOptions/ctor
 border: RO(ABGR/(DeepPink Black)%)
 borderMenu: RO(ABGR/(DeepPink Black)% true false)
 Menu: interface {
  update(delta:TimeSpan): {}
  handle_key(kb:KB): {}
  handle_mouse(state:HandState): {}
  render!: {}
 }
 SelectMenu: class {
  title:string
  items: Row-Item
  setItems(^items): {
   ^^^items := items
  }
  invoke: ValFunc * null
  escape: ValFunc * null
  time: double/Parse-"0"
  pos: XY/i(32 26)
  new(^title ^items ^invoke ^escape ^pos): SelectMenu {
   title := _0
   items := _1
   invoke := _2
   escape := _3
   pos := nullor(_4 _)
  }
  update(delta:TimeSpan): {
   time := addf(_ delta/TotalSeconds)
  }
  handle_key(kb:KB): {
   kb/IsPress ?[
    KC/Escape: {
     escape =+ null ?+ {
      menu := null
     }
    }
   ]
   kb/Press | ?(k) beq(k 65 90) ?+ {
    ind: subi(k 65)
    lt(ind items/Length) ?+
     invoke*ind
   }
  }
  handle_mouse(state:HandState): {
  }
  render!: {
   x:pos/xi y:pos/yi w:32 h:1
   Sf/DrawRect(sf_ui x y int_from*Common/Lerp(time 0 divf(1 10) 1 w h) 32 border)
   y := addi(_ 1)
   sf_ui/Print(addi(x 2) y title ABGR/(White Black)%)
   y := addi(_ 1)
   Sf/DrawRect(sf_ui x y w h borderMenu)
   ind: 0
   items | ?(it) {
    y := addi(_ 1),
    [
     (addi(x 2) y it/tile/(glyph front back)%),
     (addi(x 4) y it/name ABGR/(White Black)%),
     (subi(addi(x w) 3) y ABC@ind ABGR/(White Black)%),
    ] | sf_ui/Print
    ind := addi(_ 1)
   }
  }

  implement(Menu)
 }

 LookMenu: class {


  allowSpace: false
  title:string
  invoke: ValFunc * null
  escape: ValFunc * null
  update(delta:TimeSpan): {
  
  }
  handle_key(kb:KB): {
   kb/IsPress ?[
    KC/Escape: {
     escape =+ null ?+ {
      menu := null

      resetCamera!
     }
    }
    KC/Up: {
     camera := camera/add(XY/up)
    }
    KC/Right: {
     camera := camera/add(XY/right)
    }
    KC/Down: {
     camera := camera/add(XY/down)
    }
    KC/Left: {
     camera := camera/add(XY/left)
    }
   ]
   kb/Press | ?(k) beq(k 65 90) ?+ {
    ind: subi(k 65)
    lt(ind items/Length) ?+ 
     invoke =- null ?+ 
      invoke*ind
   }
  }
  handle_mouse(state:HandState): {
   
  }
  render!: {
   
  }
  
  implement(Menu)
 }
 ABC: "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}
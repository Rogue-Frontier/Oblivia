{

	~
	test(?): match {
		string{}: print * args
		2: print * args
		(): print * "test"
	}
	~
	BufferedList: class {
		items: HashSet-object/new!
		toAdd: HashSet-object/new!
		toRemove: HashSet-object/new!

		new!: BufferedList{}
		Add(e:object): {
			items/Contains-e ?+
				print*"already added" ?-
				toAdd/Add-e
		}
		Remove(e:object): {
			items/Contains-e ?+
				toRemove/Add-e ?-
				print*"already removed"
		}
		Update!: {
			items/UnionWith-toAdd
			items/ExceptWith-toRemove

			~
				pr: ?(e:object) print* e/name
				(items | pr)
				(toRemove | pr)
			~
			
			toAdd/Clear!
			toRemove/Clear!
		}
	}
	XY: class {
		x: double_from-0
		y: double_from-0
		xi: get* int_from-x
		yi: get* int_from-y
		xyi: get* pairi(xi yi)
		
		left: get* XY/i(subi(0 1) 0)
		right: get* XY/i(addi(0 1) 0)
		up: get* XY/i(0 subi(0 1))
		down: get* XY/i(0 addi(0 1))

		i(x:int y:int): XY {
			x := double_from-^^x
			y := double_from-^^y
		}
		f(x:double y:double): XY {
			x := ^^x
			y := ^^y
		}
		add(rhs: XY): XY {
			x := addf(^^^x rhs/x)
			y := addf(^^^y rhs/y)
		}
		sub(rhs: XY): XY {
			x := subf(^^^x rhs/x)
			y := subf(^^^y rhs/y)
		}
		div(scale:int): XY {
			x := divf(^^^x scale)
			y := divf(^^^y scale)
		}
	}
	Tile: class {
		glyph: "@"@0
		front: ABGR/Magenta
		back: ABGR/Black
		print(sf:Sf pos:XY): {
			pos % { sf/PrintChar(xi yi ^^^^glyph ^^^^front ^^^^back) }
		}
	}
	Entity: interface {
		active: bool
	}
	Floor: class {
		name: "Floor"
		pos:XY
		env: true
		active:true
		tile: Tile {
			glyph := char_from-249
			front := ABGR/Gray
			back := ABGR/Transparent
		}
		update!: {
			
		}
		new(pos:XY): Floor {
			pos := ^^pos
		}
		#register(Entity)
	}
	Enemy: class {
		hp: 100
		active: true
		name: "Enemy"
		pos: XY

		this: get* ^$
		tile: Tile {
			glyph := "E"[0]
			front := ABGR/Red
		}
		world: World
		new(pos:XY world:World): Enemy {
			pos := ^^pos
			world := ^^world
		}
		update!: {
			not-active ?+
				world/removeEntity*this	
		}
		damage(hp: int): {
			^^^hp := subi(_ hp)
			active := gt(^^^hp 0)
			#print * ^^^hp
		}
	}
	Player: class {
		name: "Player"
		pos: XY
		tile: Tile {
			glyph := "@"[0]
			front := ABGR/Magenta
		}
		active:true
		busy: false
		world: World
		log: List-string/new!
		new(pos:XY world:World): Player {
			pos := ^^pos
			world := ^^world
		}
		update!: {
			busy := false
		}
		move(disp:XY): {
			dest: pos/add*disp
			grid: world/getGrid
			others: grid[dest/xyi]

			attack: false
			others =- null ?+ {
				others |<not*attack> ?(e) {
					e/name =+ "Enemy" ?+ {
						log/Add*cat*["Attack " e/name]
						e/damage*20
						attack := true
					}
				}
			}
			not-attack ?+ {
				world/hasFloor-dest ?+ {
					pos := dest
				}
			}
			busy := true
		}
	}
	Item: class {
		type: ItemType
		pos: XY
		active: true
		tile: Tile { glyph := "r"@0  front := ABGR/White }
		new(type:ItemType pos:XY): Item {
			type := ^^type
			pos := ^^pos
			print * pos/x
		}
		update!: {
			
		}
		name: get* type/name
	}

	ItemType: class {
		name: string
	}
	World: class {
		tick: 0
		entities: BufferedList/new!
		updateGrid: true
		grid: ConcurrentDictionary(Pt HashSet-object)/new!
		new!: World{}
		addEntity: entities/Add
		removeEntity: entities/Remove
		menu: object
		update!: {
			entities/items | ?(e)
				not(e/active) ?+ {
					entities/Remove-e
				} ?- {
					e/update!
					#print* e/name
				}
			entities/Update!
			updateGrid := true
			tick := addi(_ 1)
		}
		getGrid: get* {
			not-updateGrid ?+ {
				^^ := grid
			}
			grid/Clear!
			#print* grid/Count
			entities/items | ?(e)
				grid/GetOrAdd(e/pos/xyi HashSet-object/new!)/Add-e
			updateGrid := false
			^: grid
		}
		hasFloor(p:XY): {
			loc: getGrid[p/xyi]
			b:false
			loc =- null ?+ 
				loc | ?(e)
					e/name =+ "Floor" ?+ {
						b := true
					}
			^: b
		}
	}
	time: addf(0 0)
	move: false
	player: Player
	world: World
	sf: Sf
	sf_ui: Sf
	init!: {
		world := World/new!
		range(0 30) | ?(y:int)
			range(0 30) | ?(x:int)
				world/addEntity* Floor/new* XY/i(x y)
		player := Player/new(XY/i(0 0) world)
		world/addEntity* player
		world/addEntity* Enemy/new(XY/i(10 10) world)
		world/addEntity* Item/new(ItemType { name := "gun" } XY/i(5 5))
		world/update!
		sf := Sf/new(Runner/WIDTH Runner/HEIGHT scene/FONT_8x8)
		sf_ui := Sf/new(divi(muli(4 Runner/WIDTH) 3) Runner/HEIGHT scene/FONT_6x8)

	}
	update(delta:TimeSpan): {
		time := addf(_ delta/TotalSeconds)
		player/busy ?+
			world/update!
	}
	render(delta:TimeSpan): {
		sf/Clear!
		grid: world/getGrid
		center: XY/i(sf/GridWidth sf/GridHeight)/div*2
		grid/Keys | ?(p:Pt)
			grid@p | ?(e) {
				e/tile/print(sf center/add * e/pos/sub* player/pos)
			}
		sf_ui/PrintStr(1 1 cat*["tick: " world/tick] ABGR/White ABGR/Black)
		
		y: subi(sf/GridHeight 32)
		Sf/DrawRect(sf_ui 0 y 64 32 border)
		y := addi(_ 1)
		player/log | ?(str:string) {
			sf_ui/PrintStr(1 y str ABGR/White ABGR/Black)
			y := mini(addi(_ 1) subi(sf_ui/GridHeight 1))
		}
		,[:Sf sf sf_ui] | scene/Draw/Invoke
	}
	handle_key(kb:KB): {
		player/busy ?+ { ^^ := null }
		kb/IsPress ?[
			KC/Left:	XY/left
			KC/Right:	XY/right
			KC/Up:		XY/up
			KC/Down:	XY/down
		] | player/move

		kb/IsPress ?[
			KC/G:	print*"get"
			KC/N: null
		]

	}
	handle_mouse(state:HandState): {
	}

	border: RectOptions/new(ABGR/White ABGR/Black)

}
{
    WB: ABGR/(White Black)%
    ~
    test: ?{
        (string{}): print * args
        (2): print * args
        (): print * "test"
    }
    init: match {
    }
    func(a:int void)
    func(int void)
    ~

    ~
    test: multifunc {
        2: print * "two"
        (x:int): print * x
    }
    ~
    BufferList(T): class {
        makeSet: HashSet-T/ctor
        items: makeSet!
        toAdd: makeSet!
        toRemove: makeSet!

        ^(a:int): {}
        ^@(a:int): {}

        new(): BufferList(T) {}
        Add(e:T): {
            items/Contains-e ?+
                print*"already added" ?-
                toAdd/Add-e
        }
        Remove(e:T): {
            items/Contains-e ?+
                toRemove/Add-e ?-
                print*"already removed"
        }
        Update!: {
            items/UnionWith-toAdd,
            items/ExceptWith-toRemove,
            [toAdd toRemove] | ?(t) t/Clear!
        }
    }
    XY: class {
        (x y): (0 0) | double_from
        xi: get* int_from-x
        yi: get* int_from-y
        xf: get* x
        yf: get* y
        xyi:get* pairi(xi yi)
        left:   get* XY/i(subi(0 1) 0)
        right:  get* XY/i(addi(0 1) 0)
        up:     get* XY/i(0 subi(0 1))
        down:   get* XY/i(0 addi(0 1))
        
        ~
        l: prop(
            get:null 
            set:_ null
        )
        left: set* { x := _arg }
        d: var-double
        e: val-double
        ~

        i(x:int y:int): XY {
            (x y) := double_from *| (_0 _1)
        }
        f(^x ^y): XY {
            (x y) := (_0 _1)
        }
        add(rhs:XY): XY {
            x := addf(^^^x _0/x)
            y := addf(^^^y _0/y),
        }
        sub(rhs:XY): XY {
            x := subf(^^^x _0/x)
            y := subf(^^^y _0/y)
        }
        div(scale:int): XY {
            x := divf(^^^x _0)
            y := divf(^^^y _0)
        }
    }
    Tile: class {
        glyph: "@"@0,
        (front back): ABGR/(Magenta Black),
        arr(str:string): str | ?(c:char) Tile { glyph := c front := ABGR/White back := ABGR/Black }
        print(sf:Sf pos:XY): {
            sf/PrintChar(pos/(xi yi)% ^^^(glyph front back)%)
        }
    }
    Entity: interface { active: bool }
    Env: interface {}
    Actor: interface { update(): {} }
    Chasm: class {
        name: "Chasm"
        pos: XY
        active: true
        tile: get* Tile {
            glyph := char_from-10
            front := ABGR/Gray
            back := ABGR/Transparent
        }
        new(^pos): Chasm {
            pos := _0
        }
        implement(Entity Env)
    }
    Floor: class {
        name: "Floor"
        pos:XY
        active: true
        tile: Tile {
            glyph := char_from-254
            front := ABGR/RGBA * byte_from *| (51 51 75 addi(204 rand_range(0 25)))
            back := ABGR/Transparent
        }
        new(^pos): Floor {
            pos := _0
        }
        update!: {}
        implement(Entity Env)
    }
    Wall: class {
        name: "Wall"
        pos: XY
        active: true
        tile: get* Tile {
            glyph := char_from-249
            front := ABGR/Gray
            back := ABGR/Transparent
        }
        implement(Entity Env)
    }
    Msg: class {
        tiles: Row-Tile
        time: double/Parse-"0"
        tick: int/Parse-"0"
        new(^tiles ^time ^tick): Msg {
            (tiles time tick) := (_0 _1 _2)
        }
        repeats: 1
        fadeTime: double/Parse-"0"
        once: get* repeats =+ 1
        text: get* tiles |/ glyph
    }
    Enemy: class {
        hp: 100
        active: true
        name: "Enemy"
        pos: XY
        world: World
        this: get* ^$
        tile: Tile {
            glyph := "E"@0
            front := ABGR/Red
            back := ABGR/Transparent
        }
        new(^pos ^world): Enemy {
            pos := _0
            world := _1
        }
        update!: {
            not-active ?+
                world/removeEntity*this 
        }
        damage(^hp): {
            ^^^hp := subi(_ _0)
            active := gt(^^^hp 0)
            #active := gt(_temp@0 0) #_temp@0 substitutes to ^^^hp
        }
        implement(Entity Actor)
    }
    ~
    Player: class
        name: "Player"
        pos: XY
        tile: Tile
            glyph := "@"[0]
            front := ABGR/Magenta
            back := ABGR/Transparent
        active: true
        busy: false
        world: World
        log: List-Msg/ctor!
        cargo: List-Item/ctor!
        new(^pos ^world): Player
            pos := _0
            world := _1
        update!:
            busy := false
        move(disp:XY):
            dest: pos/add*disp
            attack: false
            world/getGrid[dest/xyi] = object:o ?+ 
                o | ?(e)
                    not-attack ?+ break ?-
                    e = Enemy:e ?+ 
                        log/Add*Msg/new(Tile/arr(cat["Attack " e/name]) time world/tick)
                        e/damage*10
                        attack := true
            not-attack ?+ 
                world/hasFloor-dest ?+
                    pos := dest
            busy := true
        implement(Entity Actor)
    ~
    Player: class {
        ^(a:int): {}
        ^@(a:int): {}
        data@(a:int): {}
        name: "Player"
        pos: XY
        tile: Tile {
            glyph := "@"[0]
            front := ABGR/Magenta
            back := ABGR/Transparent
        }
        active: true
        busy: false
        world: World
        log: List-Msg/ctor!
        cargo: List-Item/ctor!
        new(^pos ^world): Player {
            pos := _0
            world := _1
        }
        update!: {
            busy := false
        }
        move(disp:XY): {
            dest: pos/add* disp
            attack: false
            world/getGrid[dest/xyi] = object:o ?+
                o | ?(e) {
                    attack ?+ { ^^:= break }
                    e = Enemy:e ?+ {
                        log/Add*Msg/new(Tile/arr(cat["Attack " e/name]) time world/tick)
                        e/damage*10
                        attack := true
                    }
                }
            not-attack ?+ {
                world/hasFloor-dest ?+ {
                    pos := dest
                }
            }
            busy := true
        }
        implement(Entity Actor)
    }
    Item: class {
        type: ItemType
        pos: XY
        active: true
        tile: Tile { glyph := "r"@0  front := ABGR/White }
        new(^type ^pos): Item {
            type := _0
            pos := _1
        }
        update!: {}
        name: get* type/name
        implement(Entity)
    }
    ItemType: class {
        name: string
    }
    World: class {
        tick: 0
        entities: BufferList-Entity/new!
        actors: BufferList-Actor/new!
        updateGrid: true
        grid: ConcurrentDictionary(Pt HashSet-Entity)/ctor!
        new!: World {}
        addEntity(e:Entity): {
            entities/Add* e
            isActor-e ?+ actors/Add* e
        }
        removeEntity(e:Entity): {
            entities/Remove(e)
            isActor(e) ?+ actors/Remove*e
        }
        isActor(e:Entity): e = Actor
        update!: {
            actors/items | ?(a)
                not(a/active) ?+
                    removeEntity-a ?-
                    a/update!
            entities/Update!
            actors/Update!
            updateGrid := b1
            tick := addi(_ 1)
        }
        forceUpdate!: {
            entities/Update!
            actors/Update!
            updateGrid := true
        }
        getGrid: get* {
            not-updateGrid ?+ { ^^ := grid }
            grid/Clear!
            #print* grid/Count
            entities/items | ?(e) grid/GetOrAdd(e/pos/xyi HashSet-Entity/ctor!)/Add*e
            updateGrid := false
            ^: grid
        }
        hasType(type p:XY): {
            getGrid[p/xyi] = object:loc ?+ 
                loc | ?(e) (e = type) ?+ { ^^^ := true }
            ^: false
        }
        hasFloor(p:XY): hasType(Floor p)
        hasWall(p:XY): hasType(Wall p)
    }
    time: double/Parse*"0"
    move: false
    camera: XY
    player: Player
    world: World
    sf: Sf
    sf_ui: Sf
    menu: Menu * null
    init!: {
        "aaa" = string:a ?+ print* a
        "aaa" ?{
            _: print*_
        }
        print * cat*[1 2, [:int 3 4]%]
        print * [1 2 3] | ?(i) i =+ 1 ?+ i
        world := World/new!
        add: world/addEntity
        range(0 30) | ?(y:int)
            range(0 30) | ?(x:int)
                add* Floor/new* XY/i(x y)
        ~
        range(0 40) | ?(y)
            range(0 40) | ?(x)
                add* Chasm/new* XY/i(x y)
        ~
        player := Player/new(XY/i(0 0) world)
        camera := player/pos
        add *| [
            player
            Enemy/new(XY/i(10 10) world)
            Item/new(ItemType { name := "gun" } XY/i(5 5))
        ]
        world/update!
        sf := Sf/ctor(Runner/(WIDTH HEIGHT)% scene/FONT_8x8)
        sf_ui := Sf/ctor(divi(muli(4 Runner/WIDTH) 3) Runner/HEIGHT scene/FONT_6x8)
    }
    update(delta:TimeSpan): {
        time := addf(_ delta/TotalSeconds)
        player/busy ?+
            world/update!
        menu = Menu:m ?+
            m/update*delta
    }
    resetCamera!: {
        camera := player/pos
    }
    center: get* XY/i(sf/(GridWidth GridHeight)%)/div* 2
    render(delta:TimeSpan): {
        [sf sf_ui] | ?(s) s/Clear!
        grid: world/getGrid
        grid/Keys | ?(p)
            grid@p | ?(e)
                e/tile/print(sf center/add*e/pos/sub*camera)
        sf_ui/Print(1 1 cat["tick: " world/tick] WB)
        invMenu: {
            x:0 y:subi(sf/GridHeight 64) w:32 h:32
            Sf/DrawRect(sf_ui x y w h border)
            y := addi(_ 1)
            sf_ui/Print(addi(x 2) y "Inventory" WB)
            y := addi(_ 1)
            Sf/DrawRect(sf_ui x y w 1 border)
            player/cargo | ?(it:Item) {
                y := addi(_ 1)
                it/tile/print(sf_ui XY/i(2 y))
                sf_ui/Print(addi(x 4) y it/name WB)
            }
        }
        log: {
            x:0 y:subi(sf/GridHeight 32) w:64 h:32
            Sf/DrawRect(sf_ui x y w h border)

            down!: { y := addi(_ 1) }
            down!
            sf_ui/Print(addi(x 2) y "Log" WB)
            down!
            Sf/DrawRect(sf_ui x y w 1 border)
            down!
            player/log | ?(msg:Msg) {
                x:2
                msg/tiles | ?(t:Tile) {
                    t/print(sf_ui XY/i(x y))
                    x := addi(_ 1)
                }
                y := mini(addi(_ 1) subi(sf_ui/GridHeight 1))
            }
        }
        menu = Menu:m ?+ m/render!
        scene/Draw/Invoke *| [sf sf_ui]
    }
    handle_key(kb:KB): {
        player/busy ?+ { ^^ := empty }
        menu = Menu:m ?+ {
            m/handle_key-kb
            ^^ := empty
        }
        kb/IsPress ?[
            KC/Left: XY/left
            KC/Right: XY/right
            KC/Up:  XY/up
            KC/Down: XY/down
        ] | ?(dir) {
            player/move*dir
            resetCamera!
        }
        kb/IsPress ?[
            KC/G: {
                items!: world/getGrid[player/pos/xyi] | ?(it)
                    (it = Item:i) ?+ { print*"YES" i } ?- print*"NO"
                print*"GET"
                menu := SelectMenu/new(
                    title: "Get Items"
                    items: items!
                    invoke: ?(i) {
                        it: menu/items@i,
                        [world/removeEntity player/cargo/Add] |*it
                        world/forceUpdate!
                        menu/setItems* items!
                    }
                )
            }
            KC/S: {
                menu := SelectMenu/new(
                    title: "Fire Item"
                    items: player/cargo/ToArray!
                    invoke: ?(ind) {
                        it: menu/items@ind
                        menu := TargetMenu/new(
                            title: "Fire Target"
                            invoke: ?(ind) {
                                target: menu/items
                                print * target
                            }
                        )
                        # menu/setItems* player/cargo/ToArray!
                    }
                    pos: XY/i(32 26)
                )
            }
            KC/N: empty
        ]
    }
    handle_mouse(state:HandState): {
        menu = Menu:m ?+
            m/handle_mouse*state
    }
    RO: RectOptions/ctor
    border: RO(ABGR/(DeepPink Black)%)
    borderMenu: RO(ABGR/(DeepPink Black)% true false)
    Menu: interface {
        update(delta:TimeSpan): empty
        handle_key(kb:KB): empty
        handle_mouse(state:HandState): empty
        render(): empty
    }
    SelectMenu: class {
        title:string
        items: Row-Item
        setItems(^items): {
            ^^^items := items
        }
        invoke: ValFunc* null
        escape: ValFunc* null
        time: double/Parse-"0"
        pos: XY/i(32 26)
        new(^title ^items ^invoke ^escape ^pos): SelectMenu {
            title := _0
            items := _1
            invoke := _2
            escape := _3
            pos := nullor(_4 _)
        }
        update(delta:TimeSpan): {
            time := addf(_ delta/TotalSeconds)
        }
        handle_key(kb:KB): {
            kb/IsPress ?[
                KC/Escape: {
                    escape =+ null ?+ {
                        menu := null
                    } ?- escape!
                }
            ]
            kb/Press | ?(k) beq(k 65 90) ?+ {
                ind: subi(k 65)
                lt(ind items/Length) ?+
                    invoke*ind
            }
        }
        handle_mouse(state:HandState): {
        }
        render!: {
            x:pos/xi y:pos/yi w:32 h:32
            Sf/DrawRect(sf_ui x y int_from*Common/Lerp(time 0 divf(1 10) 1 w 1) h border)
            y := addi(_ 1)
            sf_ui/Print(addi(x 2) y title WB)
            y := addi(_ 1)
            Sf/DrawRect(sf_ui x y w 1 borderMenu)
            ind: 0
            items | ?(it) {
                y := addi(_ 1)
                
                sf_ui/Print *| [
                    (addi(x 2) y it/tile/(glyph front back)%),
                    (addi(x 4) y it/name WB),
                    (subi(addi(x w) 3) y ABC@ind WB),
                ]
                ind := addi(_ 1)
            }
        }
        implement(Menu)
    }
    TargetMenu: class {
        allowSpace: false
        title: string
        invoke: ValFunc*null
        escape: ValFunc*null
        time: double/Parse-"0"
        interval: double/Parse-"0.5"
        items: Row-object* null
        pos: XY/i(32 26)
        new(^title ^invoke ^escape ^pos): TargetMenu {
            title := _0
            invoke := _1
            escape := _2
            pos := nullor(_3 _)
        }
        update(delta:TimeSpan): {
            time := addf(delta/TotalSeconds _)
        }
        updateItems!: {
            items := world/getGrid[camera/xyi] | ?(o) o
        }
        handle_key(kb:KB): {
            kb/IsPress ?[
                KC/Escape: {
                    escape = object:e ?+
                        e! ?- {
                            menu := null
                            resetCamera!
                        }
                }
            ]
            move(off:XY): {
                camera := camera/add(off)
                updateItems!
            }
            move *| kb/IsPress ?[
                KC/Up:      XY/up
                KC/Right:   XY/right
                KC/Down:    XY/down
                KC/Left:    XY/left
            ]
            kb/Press | ?(k) beq(k 65 90) ?+ {
                ind: subi(k 65)
                and(items = object:it lt(ind it/Length)) ?+
                    invoke = object:inv ?+ 
                        inv*ind
            }
        }
        handle_mouse(state:HandState): {}
        marker: Tile { glyph := "X"@0 front := ABGR/Yellow }
        render(): {
            lt(modf(time interval) divf(interval 2)) ?+
                marker/print(sf center)
            x:32 y:26 w:32 h:32
            Sf/DrawRect(sf_ui x y w h border)
            y := addi(_ 1)
            sf_ui/Print(addi(x 2) y title WB)
            y := addi(_ 1)
            Sf/DrawRect(sf_ui x y w 1 border)
            ind: 0
            (items = object) ?+
                items | ?(it:Entity) {
                    y := addi(_ 1)
                    it/tile/print(sf_ui XY/i(addi(x 2) y))
                    sf_ui/Print(addi(x 4) y it/name WB)
                    sf_ui/Print(subi(addi(x w) 2) y ABC@ind WB)
                    ind := addi(ind 1)
                }
        }
        implement(Menu)
    }
    ABC: "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}